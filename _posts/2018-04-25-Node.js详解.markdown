---
layout: post
title: "Node.js详解"
date: 2018-04-25
categories:
  - Juice
description: 
image: https://unsplash.it/2000/1200?image=52
image-sm: https://unsplash.it/2000/1200?image=52
---

Node.js  最重要的3点：
1.单线程
单线程的好处：减少了内存开销，就像操作系统中的内存换页。
2.非阻塞I/O
如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。
不会傻等I/O语句结束，而会执行后面的语句。非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？

由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。
当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。
阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

3.event-driven
事件机制，事件环，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。

说是三个特点，实际上是一个特点，离开谁都不行，都玩儿不转了。
Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。
Node.js中所有的I/O都是异步的，回调函数，套回调函数。

#事件驱动event-driven

在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。
Node.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度

![image.png](https://upload-images.jianshu.io/upload_images/3378252-2df6924294aa95ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#Node.js适合开发什么？

善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。

当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与web socket配合，开发长连接的实时交互应用程序。

昨天面腾讯的时候，面试官提到了如何用node中的http模块搭建一个服务器。
```
var http=require('http');

var server=http.createServer(function (req,res) {
    res.send("你好");
})

server.listen(3000,"127.0.0.1");
```

又问了一个问题，如果用node搭建websocket
